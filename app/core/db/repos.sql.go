// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repos.sql

package db

import (
	"context"
)

const repoArtifactByType = `-- name: RepoArtifactByType :many
SELECT 
  id, type, data, repository_id 
FROM  
  repository_artifact 
WHERE 
  repository_id = ? 
  AND type = ?
`

type RepoArtifactByTypeParams struct {
	RepositoryID int64
	Type         string
}

func (q *Queries) RepoArtifactByType(ctx context.Context, arg RepoArtifactByTypeParams) ([]RepositoryArtifact, error) {
	rows, err := q.db.QueryContext(ctx, repoArtifactByType, arg.RepositoryID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepositoryArtifact
	for rows.Next() {
		var i RepositoryArtifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Data,
			&i.RepositoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const repoArtifacts = `-- name: RepoArtifacts :many
SELECT
  id, type, data, repository_id 
FROM  
  repository_artifact 
WHERE 
  repository_id = ?
`

func (q *Queries) RepoArtifacts(ctx context.Context, repositoryID int64) ([]RepositoryArtifact, error) {
	rows, err := q.db.QueryContext(ctx, repoArtifacts, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepositoryArtifact
	for rows.Next() {
		var i RepositoryArtifact
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Data,
			&i.RepositoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const repoCreate = `-- name: RepoCreate :one
INSERT INTO 
  repository (remote_id, name, username, description, clone_url, clone_ssh_url, is_fork)
VALUES 
  (?, ?, ?, ?, ?, ?, ?)
RETURNING 
  id, remote_id, name, username, description, clone_url, clone_ssh_url, is_fork
`

type RepoCreateParams struct {
	RemoteID    string
	Name        string
	Username    string
	Description string
	CloneUrl    string
	CloneSshUrl string
	IsFork      bool
}

func (q *Queries) RepoCreate(ctx context.Context, arg RepoCreateParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, repoCreate,
		arg.RemoteID,
		arg.Name,
		arg.Username,
		arg.Description,
		arg.CloneUrl,
		arg.CloneSshUrl,
		arg.IsFork,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.RemoteID,
		&i.Name,
		&i.Username,
		&i.Description,
		&i.CloneUrl,
		&i.CloneSshUrl,
		&i.IsFork,
	)
	return i, err
}

const repoCreateArtifact = `-- name: RepoCreateArtifact :one
INSERT INTO 
  repository_artifact (repository_id, type, data)  
VALUES 
  (?, ?, ?)
RETURNING
  id, type, data, repository_id
`

type RepoCreateArtifactParams struct {
	RepositoryID int64
	Type         string
	Data         []byte
}

func (q *Queries) RepoCreateArtifact(ctx context.Context, arg RepoCreateArtifactParams) (RepositoryArtifact, error) {
	row := q.db.QueryRowContext(ctx, repoCreateArtifact, arg.RepositoryID, arg.Type, arg.Data)
	var i RepositoryArtifact
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Data,
		&i.RepositoryID,
	)
	return i, err
}

const repoUpsert = `-- name: RepoUpsert :one
INSERT INTO 
  repository (remote_id, name, username, description, clone_url, clone_ssh_url, is_fork)  
VALUES 
  (?, ?, ?, ?, ?, ?, ?) 
ON CONFLICT (remote_id) 
DO UPDATE SET 
  name = EXCLUDED.name, 
  username = EXCLUDED.username, 
  description = EXCLUDED.description, 
  clone_url = EXCLUDED.clone_url, 
  clone_ssh_url = EXCLUDED.clone_ssh_url, 
  is_fork = EXCLUDED.is_fork  
RETURNING id, remote_id, name, username, description, clone_url, clone_ssh_url, is_fork
`

type RepoUpsertParams struct {
	RemoteID    string
	Name        string
	Username    string
	Description string
	CloneUrl    string
	CloneSshUrl string
	IsFork      bool
}

func (q *Queries) RepoUpsert(ctx context.Context, arg RepoUpsertParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, repoUpsert,
		arg.RemoteID,
		arg.Name,
		arg.Username,
		arg.Description,
		arg.CloneUrl,
		arg.CloneSshUrl,
		arg.IsFork,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.RemoteID,
		&i.Name,
		&i.Username,
		&i.Description,
		&i.CloneUrl,
		&i.CloneSshUrl,
		&i.IsFork,
	)
	return i, err
}

const reposByNameLike = `-- name: ReposByNameLike :many
SELECT 
  id, remote_id, name, username, description, clone_url, clone_ssh_url, is_fork 
FROM  
  repository 
WHERE 
  name LIKE ?
`

func (q *Queries) ReposByNameLike(ctx context.Context, name string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposByNameLike, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposByUsernameLike = `-- name: ReposByUsernameLike :many
SELECT 
  id, remote_id, name, username, description, clone_url, clone_ssh_url, is_fork 
FROM 
  repository 
WHERE 
  username LIKE ?
`

func (q *Queries) ReposByUsernameLike(ctx context.Context, username string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposByUsernameLike, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposGetAll = `-- name: ReposGetAll :many
SELECT 
  id, remote_id, name, username, description, clone_url, clone_ssh_url, is_fork 
FROM  
  repository
`

func (q *Queries) ReposGetAll(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposGetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
