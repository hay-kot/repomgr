// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repos.sql

package db

import (
	"context"
)

const repoArtifactByType = `-- name: RepoArtifactByType :many
SELECT 
  id, data_type, data, repository_id 
FROM  
  repository_artifact 
WHERE 
  repository_id = ? 
  AND data_type = ?
`

type RepoArtifactByTypeParams struct {
	RepositoryID int64
	DataType     string
}

func (q *Queries) RepoArtifactByType(ctx context.Context, arg RepoArtifactByTypeParams) ([]RepositoryArtifact, error) {
	rows, err := q.db.QueryContext(ctx, repoArtifactByType, arg.RepositoryID, arg.DataType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepositoryArtifact
	for rows.Next() {
		var i RepositoryArtifact
		if err := rows.Scan(
			&i.ID,
			&i.DataType,
			&i.Data,
			&i.RepositoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const repoArtifacts = `-- name: RepoArtifacts :many
SELECT
  id, data_type, data, repository_id 
FROM  
  repository_artifact 
WHERE 
  repository_id = ?
`

func (q *Queries) RepoArtifacts(ctx context.Context, repositoryID int64) ([]RepositoryArtifact, error) {
	rows, err := q.db.QueryContext(ctx, repoArtifacts, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepositoryArtifact
	for rows.Next() {
		var i RepositoryArtifact
		if err := rows.Scan(
			&i.ID,
			&i.DataType,
			&i.Data,
			&i.RepositoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const repoCreate = `-- name: RepoCreate :one
INSERT INTO 
  repository (
      remote_id, 
      name, 
      username, 
      description, 
      html_url, 
      clone_url, 
      clone_ssh_url, 
      is_fork,
      fork_url
  )
VALUES 
  (?, ?, ?, ?, ?, ?, ?, ?, ?) 
RETURNING 
  id, remote_id, name, username, description, html_url, clone_url, clone_ssh_url, is_fork, fork_url
`

type RepoCreateParams struct {
	RemoteID    string
	Name        string
	Username    string
	Description string
	HtmlUrl     string
	CloneUrl    string
	CloneSshUrl string
	IsFork      bool
	ForkUrl     string
}

func (q *Queries) RepoCreate(ctx context.Context, arg RepoCreateParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, repoCreate,
		arg.RemoteID,
		arg.Name,
		arg.Username,
		arg.Description,
		arg.HtmlUrl,
		arg.CloneUrl,
		arg.CloneSshUrl,
		arg.IsFork,
		arg.ForkUrl,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.RemoteID,
		&i.Name,
		&i.Username,
		&i.Description,
		&i.HtmlUrl,
		&i.CloneUrl,
		&i.CloneSshUrl,
		&i.IsFork,
		&i.ForkUrl,
	)
	return i, err
}

const repoUpdateArtifact = `-- name: RepoUpdateArtifact :exec
UPDATE
  repository_artifact
SET
  data = ?
WHERE 
  repository_id = ?
  AND data_type = ?
`

type RepoUpdateArtifactParams struct {
	Data         []byte
	RepositoryID int64
	DataType     string
}

func (q *Queries) RepoUpdateArtifact(ctx context.Context, arg RepoUpdateArtifactParams) error {
	_, err := q.db.ExecContext(ctx, repoUpdateArtifact, arg.Data, arg.RepositoryID, arg.DataType)
	return err
}

const repoUpsert = `-- name: RepoUpsert :one
INSERT INTO 
  repository (
      remote_id, 
      name, 
      username, 
      description, 
      html_url, 
      clone_url, 
      clone_ssh_url, 
      is_fork,
      fork_url  
  ) 
VALUES 
  (?, ?, ?, ?, ?, ?, ?, ?, ?) 
ON CONFLICT (remote_id) 
DO UPDATE SET 
  name = EXCLUDED.name, 
  username = EXCLUDED.username, 
  description = EXCLUDED.description, 
  html_url = EXCLUDED.html_url, 
  clone_url = EXCLUDED.clone_url, 
  clone_ssh_url = EXCLUDED.clone_ssh_url, 
  is_fork = EXCLUDED.is_fork
RETURNING id, remote_id, name, username, description, html_url, clone_url, clone_ssh_url, is_fork, fork_url
`

type RepoUpsertParams struct {
	RemoteID    string
	Name        string
	Username    string
	Description string
	HtmlUrl     string
	CloneUrl    string
	CloneSshUrl string
	IsFork      bool
	ForkUrl     string
}

func (q *Queries) RepoUpsert(ctx context.Context, arg RepoUpsertParams) (Repository, error) {
	row := q.db.QueryRowContext(ctx, repoUpsert,
		arg.RemoteID,
		arg.Name,
		arg.Username,
		arg.Description,
		arg.HtmlUrl,
		arg.CloneUrl,
		arg.CloneSshUrl,
		arg.IsFork,
		arg.ForkUrl,
	)
	var i Repository
	err := row.Scan(
		&i.ID,
		&i.RemoteID,
		&i.Name,
		&i.Username,
		&i.Description,
		&i.HtmlUrl,
		&i.CloneUrl,
		&i.CloneSshUrl,
		&i.IsFork,
		&i.ForkUrl,
	)
	return i, err
}

const repoUpsertArtifact = `-- name: RepoUpsertArtifact :one
INSERT INTO 
  repository_artifact (repository_id, data_type, data)  
VALUES 
  (?, ?, ?)
ON CONFLICT (repository_id, data_type)
DO UPDATE SET 
  data = EXCLUDED.data  
RETURNING
  id, data_type, data, repository_id
`

type RepoUpsertArtifactParams struct {
	RepositoryID int64
	DataType     string
	Data         []byte
}

func (q *Queries) RepoUpsertArtifact(ctx context.Context, arg RepoUpsertArtifactParams) (RepositoryArtifact, error) {
	row := q.db.QueryRowContext(ctx, repoUpsertArtifact, arg.RepositoryID, arg.DataType, arg.Data)
	var i RepositoryArtifact
	err := row.Scan(
		&i.ID,
		&i.DataType,
		&i.Data,
		&i.RepositoryID,
	)
	return i, err
}

const reposByNameLike = `-- name: ReposByNameLike :many
SELECT 
  id, remote_id, name, username, description, html_url, clone_url, clone_ssh_url, is_fork, fork_url 
FROM  
  repository 
WHERE 
  name LIKE ?
`

func (q *Queries) ReposByNameLike(ctx context.Context, name string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposByNameLike, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.HtmlUrl,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
			&i.ForkUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposByUsernameLike = `-- name: ReposByUsernameLike :many
SELECT 
  id, remote_id, name, username, description, html_url, clone_url, clone_ssh_url, is_fork, fork_url 
FROM 
  repository 
WHERE 
  username LIKE ?
`

func (q *Queries) ReposByUsernameLike(ctx context.Context, username string) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposByUsernameLike, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.HtmlUrl,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
			&i.ForkUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposGetAll = `-- name: ReposGetAll :many
SELECT 
  id, remote_id, name, username, description, html_url, clone_url, clone_ssh_url, is_fork, fork_url 
FROM  
  repository
`

func (q *Queries) ReposGetAll(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.QueryContext(ctx, reposGetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(
			&i.ID,
			&i.RemoteID,
			&i.Name,
			&i.Username,
			&i.Description,
			&i.HtmlUrl,
			&i.CloneUrl,
			&i.CloneSshUrl,
			&i.IsFork,
			&i.ForkUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
